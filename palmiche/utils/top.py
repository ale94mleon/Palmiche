#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import pandas as pd
import os
from palmiche import __version__
from typing import Union, Iterable

class TOP:
    def __init__(self, file:str) -> None:
        """The constructor of topology

        Parameters
        ----------
        file : str
            The path of the topology file
        """
        self.file = file
        self.data = None #is not possible to use dict because there is some repeated sections, like dihedrals, I don't know why
        self._read()

    def _read(self):
        """Reader of self.file
        """
        with open(self.file,"r") as top:
            top_lines = top.readlines()
        section_list = []
        for i in range(len(top_lines)):
            if top_lines[i].startswith("["):

                key = ""
                for char in top_lines[i]:
                    if char == "]":
                        break
                    if char not in "[ ":
                        key += char
                key.strip()
                info = []
                for j in range(i + 1, len(top_lines)):
                    if top_lines[j].startswith("["):
                        i = j - 1
                        break
                    info.append(top_lines[j])
                section_list.append([key.strip(), info])
        self.data = pd.DataFrame(section_list, columns=['section', 'content'])
        self.data.set_index('section', inplace=True)

    def write(self, outfile:str = 'topology.top'):
        """Write topology, all the modifications
        are taken into account.

        Parameters
        ----------
        outfile : str, optional
            The path to write the topology, by default 'topology.top'
        """
        with open(outfile, 'w') as of:
            of.write(f"; Generated by Palmiche: {__version__}\n")
            for index, row in self.data.iterrows():
                if index:
                    of.write(f"\n[ {index} ]\n")
                else:
                    of.write('\n')
                for line in row['content']:
                    of.write(line)

    def get_section(self, section:str):
        """Get one section of the topology

        Parameters
        ----------
        section : str
            The name of the section to get.top

        Returns
        -------
        list[str]
            A list of string that represent the content of the topology section.
        """
        return self.data.loc[section, 'content']

    def pop_section(self, section:str):
        """The same get_section() is called
        and the section is deleted from the topology

        Parameters
        ----------
        section : str
            The name of the section to get.top

        Returns
        -------
        list[str]
            A list of string that represent the content of the topology section.
        """
        tmp_data = self.data.copy()
        pop_element = self.get_section(section)
        self.data = tmp_data.drop(section)
        return pop_element

    def del_section(self, section:str):
        """Delete the section form the topology.

        Parameters
        ----------
        section : str
            The name of the section to get.top
        """
        self.data = self.data.drop(section)

    def append_section(self, content:list[str], section:Union[int, str] = 0):
        """Add to the end of the topology a new section

        Parameters
        ----------
        content : list[str]
            The content of the section as a list of strings
        section : Union[int, str], optional
            the identification of the section, by default 0
        """
        if not isinstance(content, list) and isinstance(content, str):
            content = [content]

        df = pd.DataFrame(columns=['section','content'])
        df.loc[0,'section'] = section
        df.loc[0,'content'] = content
        df.set_index('section', inplace=True)
        self.data = pd.concat([self.data,df])

    def make_posres(self, heavy_atoms_only = True, posre_name:str = None, fcx_fcy_fcz:Iterable = ('POSRES_LIG','POSRES_LIG','POSRES_LIG')):
        """It create a position restraint itp file for GROMACS.
        The corresponded include statement is added to the topology.

        Parameters
        ----------
        heavy_atoms_only : bool, optional
            Only use the index of the heavy atoms, by default True
        posre_name : str, optional
            The name of the position restrain file, by default None
        fcx_fcy_fcz : Iterable, optional
            The xyz component of the force constant, by default ('POSRES_LIG','POSRES_LIG','POSRES_LIG')
        """
        if not posre_name:
            posre_name = os.path.basename(self.file).split('.')[0]

        include_statement = "; Include Position restraint file for heavy atoms\n"\
                            "#ifdef POSRES\n"\
                            f"#include \"{posre_name}_posre.itp\"\n"\
                            "#endif"
        self.append_section(content=include_statement, section=0)

        atom_section =self.get_section("atoms")
        #This is necessary because the commented lines in gromacs topology files
        atoms = (line for line in atom_section if not line.startswith(";"))
        if heavy_atoms_only:
            atom_indexes = []
            for atom in atoms:
                split = atom.strip().split()#strip for the case of blank lines
                if split:#The list has something, this is all for the case of blank lines
                    if split[4][0].lower() != "h": #This is the column that has the atom name, I select the first char because could be H0, HH13, etc, and all of them are Hydrogens atoms, hoping that all of them start with H
                        atom_indexes.append(split[0])#Here is the column that has the atom index
        else:
            atom_indexes = len(list(atoms))
        #Writing the posre file
        with open(f"{posre_name}_posre.itp", "w") as posre:
            posre.write("[ position_restraints ]\n")
            posre.write(f"{';i':<5}{'funct':^5}{'fcx':^20}{'fcy':^20}{'fcz':^20}\n")
            for atom_index in atom_indexes:
                posre.write(f"{atom_index:^5}{1:^5}{fcx_fcy_fcz[0]:^20}{fcx_fcy_fcz[1]:^20}{fcx_fcy_fcz[2]:^20}\n")


if __name__ == '__main__':
    pass